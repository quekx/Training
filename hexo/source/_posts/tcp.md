---
title: 学习笔记(3):TCP
date: 2017-04-05 23:12:47
categories: 
- Network
tags:
- TCP
- Java
toc: true
---

### 关于TCP
TCP传输控制协议（Transmission Control Protocol）是面向连接的传输层协议，提供可靠的字节流传输。

TCP特点：

* 面向连接的传输层协议
* 可靠传输
* 面向字节流传输
* 全双工通信

TCP把连接作为基本的抽象，每个连接两端为两个套接字socket，socket由IP地址+端口号组成。

TCP保证报文按顺序，不重复发送报文，则需要对分组进行编号，以字节为基准。

可靠传输原理

1. 报文确认机制。发送方发送一个报文，接收方在成功接收后会向发送方发送一个确认报文，确认的序号为期望的下一步接收的起始字节编号。接收方接收后便确认该序号之前的字节分组均成功送达。
2. 发送方超时重传。发送方发送一个分组不会立即删除而是缓存该分组，同时设置一个超时计时器，若在超时时间段内未收到接收方发送的确认报文，则会重传该分组；若在时间段内收到确认，则删除该分组缓存。
3. 接收方重复确认。接收方收到重复的报文时，说明确认报文由于丢失未到达发送方，需要重传确认报文，并丢弃该重复报文。确认按累计确认的方式，接收方收到连续的多个分组，只需要对最后一个分组进行确认即可，这样保证确认序号之前的所有数据均已接收。

<!-- more -->

### TCP首部

| 2字节   | 2字节 |
|:-------------: |:---------------:|
| 源端口 | 目的端口 |
| 发送序号 | 发送序号 |
| 确认序号 | 确认序号 |
| 数据偏移、标志位 | 接受窗口 |
| 检验和 | 紧急指针 |
| 选项 | 填充 |

前20字节（至紧急指针）为固定格式。

数据偏移：TCP报文中数据在TCP报文的偏移位置，即使报文首部的长度。

标志位：

* URG：紧急标志位，标志有紧急数据需要优先传输，紧急指针有效，紧急指针表示紧急数据的长度，紧急数据之后为普通数据。
* ACK：确认标志位，表示确认为有效。
* PSH：推送标志位，表示该报文需尽快推送给上传应用，不等待至缓存区满。
* RST：复位标志位，表示TCP连接出现严重错误，需重新连接。
* SYN：同步标志位，用于标志建立连接消息。
* FIN：终止标志位，用于标志释放连接消息。

接受窗口：告诉发送方可以接受多长的数据。

检验和：加上伪首部信息（IP源地址，IP目的地址，全零（1字节）+协议号（1字节）+TCP报文长度（2字节）），与整个TCP报文（补零对其）相与得到结果并取反。接收方检验：按相同方式计算结果应全为一。


### 滑动窗口

TCP发送方维护着一个发送窗口，发送窗口受到拥塞窗口和接收窗口大小的影响，位于发送窗口内的字节数据可以被发送，可包含多个分组，这样可以同时发送多个分组，不需要一个一个发送分组并等待确认，提高了发送效率。

### 拥塞控制

TCP发送方维护一个拥塞窗口，会根据发送报文的重传情况来判断网络状态，并以此来动态调整拥塞窗口的大小。

* 慢开始和拥塞避免

慢开始算法和拥塞避免算法往往配合使用。

慢开始：该算法有一个门限值，开始时拥塞窗口大小为1（单位为报文段个数），小于门限值时，若没有发生重传，则执行慢开始算法，以两倍的速率增大窗口。

拥塞避免：当到达门限值时，执行拥塞避免算法，拥塞窗口大小增长速率变为每次增加1；若是发生了一次重传，则将门限值设为窗口大小的一半，拥塞窗口设为初始值1，重新开始执行慢开始算法。

* 快重传和快开始

快重传和快开始算法也往往配合使用。

快重传：算法要求接收方每收到一个失序的报文时，如收到M1、M3、M4、M5，就立即向发送方发送之前收到的报文确认（确认M1），以通知发送方中间存在报文丢失。发送方在连续收到三个重复的确认之后，判断M2未送达，则重新发送M2分组。

快开始：发送方连续收到三个确认报文，就将门限值设为窗口大小的一半，并认为网络很可能没有发送拥塞（连续收到三个报文），因此就将拥塞窗口大小直接设置为门限值，执行拥塞避免算法。

### 三次握手
TCP连接的建立需要发送三次报文后确立，俗称三次握手。

过程如下：

* 客户端A主动发起连接，TCP进程首先创建传输控制模块TCB，然后想服务端B发出连接请求报文。报文中同步标志位SYN=1，同时选择一个初始序号seq=x，然后客户端A进入SYN_SENT状态。此报文需要消耗一个序号。
* 服务端B起始处于LISTEN监听状态，收到请求报文后，同意则向A发送确认。确认报文中同步标志位SYN=1，同样选择一个初始序号seq=y；确认标志位ACK=1，确认序号ack=x+1，然后服务端B进入SYN_RCVD状态。此报文需要消耗一个序号。
* 客户端A收到确认报文后，也需要给B发送一个确认报文。报文中ACK=1，ack=y+1，seq=x+1，然后进入ESTABLISHED状态。此报文若未携带数据，则不消耗序号（下个报文序号依然为x+1）。
* 服务端B收到A的确认报文后，也进入ESTABLISHED状态。

三次握手的好处：若只有两次发送报文，服务器只收到一次请求报文就进入连接建立状态；假如客户端的某次连接建立请求滞留在网络中延时到达，但是客户端在之前已经建立连接并交换完数据断开，这就会导致服务端收到延时的请求报文时，就进入ESTABLISHED状态，但客户端并未发起请求，导致资源的浪费。

### 四次挥手
TCP连接的断开需要发送四次报文后确立，俗称四次挥手。

过程如下：

* 客户端A发起断开连接，向服务端B发送释放连接报文。报文中终止标志位FIN=1，报文序号seq=u（接之前发送的字节序号），然后客户端A进入FIN-WAIT-1状态。此报文需要消耗一个序号。
* 服务端B接受到终止报文后向A发送确认。确认报文中确认标志位ACK=1，确认序号ack=u+1，然后B进入CLOSE_WAIT状态。此时B还能够发送未发送完的数据，TCP连接处于半关闭状态。
* 客户端A收到确认报文后，进入FIN-WAIT-2状态，可继续接受数据，并等待服务端B发送终止报文。
* 服务端B发送完所有数据之后，向A发送一个终止报文。报文中FIN=1，seq=w（接之前发送的字节序号），ACK=1，确认序号ack=u+1，然后B进入LAST-ACK状态。
* 客户端A收到终止报文后，再次发送确认。报文中ACK=1，seq=u+1，ack=w+1，然后进入TIME-WAIT状态，在此状态等待2MSL（最长报文段寿命）时间后，进入CLOSED状态。
* 服务端B收到确认后，进入CLOSED状态。

客户端A要在TIME-WAIT状态等待2MSL时间的意义是：

若A发送完最后的确认就关闭，假如确认报文未到达服务端B，则B会一直处于LAST-ACK状态；而等待2MSL时，假如确认报文未到达B，B会认为之前的终止报文并未发送到达A，则重新发送该报文，在A重新收到终止报文后，会重传确认报文，使B按正常步骤进入CLOSED状态。

### Java中TCP基本使用

Java中服务端使用SocketServer，客户端使用Socket来建立连接通信。
客户端：

```
// 通过IP和端口创建Socket对象
Socket socket = new Socket("127.0.0.1", 9527)
// 通过Socket对象获取输入输出流，进行输入输出字节操作
InputStream in = socket.getInputStream();
InputStream out = socket.getOutputStream();
```

服务端：

```
// 通过监听的端口创建ServerSocket对象
ServerSocket serverSocket = new ServerSocket(9527);
// 通过accept()方法来获取一个Socket，获取Socket对象后就可以进行输入输出的字节操作了
// accept()方法为阻塞方法，会阻塞直到某个Socket连接建立
Socket socket = serverSocket.accept();
```
