---
title: Java知识点
date: 2017-04-10 19:32:09
categories: 
- tips
tags:
- Java
toc: true 
---

## Java知识点总结，不定时更新......

### 1. Thread和Runnable区别
Java中继承Thread类和实现Runnable接口是两中实现多线程的方式。
一般来说，继承某个类通常是为了利用和修改它的行为或者属性，如果不需要对原有类的行为做出改变，采用实现Runnable接口的形式更为方便。

### 2. HashMap和TreeMap
两者都是Key-Value的形式来存储数据。

#### HashMap: 
底层以散列表的形式实现，HashMap内部存储一个数组table，大小length为2的整数次幂。

table数组用于存放链表节点，当插入或查找时，将key的hash和length-1进行与操作，得到在数组中索引位置index，从而得到对应的链表进行插入或者查找操作。

以链表来存储，可以防止hash碰撞造成的冲突。碰撞程度受到hash函数的分散程度影响。平均来说链表长度不会太长，平均性能为O(1)。

链表节点以固定大小的数组来存储，当数据量不断变大时，必定会造成碰撞程度增大，链表长度变长，影响性能；当数据量大于数组大小的一定程度时(默认为75%)，数组会变为2倍来扩容，将根据hash值重新计算原先数据的位置。

数组大小扩容为2倍，保证大小length为2的整数次幂。2倍的原因是：数组中索引位置index的计算方式为，key的hash值和length-1进行与操作，为了使index分布更加平均，充分利用hash中的各个比特位，使尽可能多的比特位对结果产生相等的影响；当length为2的整数次幂时，length-1比特位全为1，能充分利用hash值中的所有较低位比特。

在JDK8中，当链表长度大于一定值时(默认为8)，链表会调整为红黑树来存储，来优化性能。

<!-- more -->

#### TreeMap
底层以红黑树的形式实现。

在树节点中存储Key、Value值，红黑树是自平衡的二叉搜索树，在树的结构改变时会平衡树的高度，其性能为O(lg(n))。

#### 区别：
* HashMap的性能复杂度为O(1)，TreeMap的性能复杂度为O(lg(n))。
* HashMap在大小到达一定值时需要扩容，TreeMap不需要扩容。
* HashMap是无序的，TreeMap底层为二叉搜索树，保存有Key的大小顺序信息。

### 3. 类的加载
类的加载会经历三个步骤：

* 加载
* 链接（验证、准备、解析）
* 初始化

#### 加载：
将类的二进制class文件加载进虚拟机内存
#### 链接：
验证：

1. 验证class文件的格式，比如开始字节为0xCAFFBABE等
2. 验证class文件的元数据，比如类的是否有父类（除了Object的所有类均有父类）等
3. 验证class文件的字节码，比如字节码不会跳转至方法外等

准备：
为类中的static类变量分配空间，并初始化为初始默认值。这里的初始化为变量的默认值，如int为0，boolean为false等。除了一种情况，声明为final的static类变量，编译器在编译时会加入CONSTANT-VALUE属性，在准备阶段即初始化为对应值。

解析：
将类中的字符引用转化为直接引用
#### 初始化
执行生成的cinit方法，来执行类中的static变量赋值语句和static语句块。

如果继承了父类，会先进行父类的初始化，然后才进行本类的初始化

如果实现了接口，不会初始化相应的接口，只会在接口使用到后才进行初始化。
