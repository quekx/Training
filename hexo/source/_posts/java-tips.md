---
title: Java 知识点
date: 2017-04-10 19:32:09
categories: 
- tips
tags:
- Java
toc: true 
---

### Thread和Runnable区别
Java中继承Thread类和实现Runnable接口是两中实现多线程的方式。
一般来说，继承某个类通常是为了利用和修改它的行为或者属性，如果不需要对原有类的行为做出改变，采用实现Runnable接口的形式更为方便。

### HashMap和TreeMap
两者都是Key-Value的形式来存储数据。

#### HashMap: 
底层以散列表的形式实现，HashMap内部存储一个数组table，大小length为2的整数次幂。

table数组用于存放链表节点，当插入或查找时，将key的hash和length-1进行与操作，得到在数组中索引位置index，从而得到对应的链表进行插入或者查找操作。

以链表来存储，可以防止hash碰撞造成的冲突。碰撞程度受到hash函数的分散程度影响。平均来说链表长度不会太长，平均性能为O(1)。

链表节点以固定大小的数组来存储，当数据量不断变大时，必定会造成碰撞程度增大，链表长度变长，影响性能；当数据量大于数组大小的一定程度时(默认为75%)，数组会变为2倍来扩容，将根据hash值重新计算原先数据的位置。

数组大小扩容为2倍，保证大小length为2的整数次幂。2倍的原因是：数组中索引位置index的计算方式为，key的hash值和length-1进行与操作，为了使index分布更加平均，充分利用hash中的各个比特位，使尽可能多的比特位对结果产生相等的影响；当length为2的整数次幂时，length-1比特位全为1，能充分利用hash值中的所有较低位比特。

在JDK8中，当链表长度大于一定值时(默认为8)，链表会调整为红黑树来存储，来优化性能。

<!-- more -->

#### TreeMap
底层以红黑树的形式实现。

在树节点中存储Key、Value值，红黑树是自平衡的二叉搜索树，在树的结构改变时会平衡树的高度，其性能为O(lg(n))。

#### 区别：
* HashMap的性能复杂度为O(1)，TreeMap的性能复杂度为O(lg(n))。
* HashMap在大小到达一定值时需要扩容，TreeMap不需要扩容。
* HashMap是无序的，TreeMap底层为二叉搜索树，保存有Key的大小顺序信息。

### 类的加载
类的加载会经历三个步骤：

* 加载
* 链接（验证、准备、解析）
* 初始化

#### 加载：
将类的二进制class文件加载进虚拟机内存
#### 链接：
验证：

1. 验证class文件的格式，比如开始字节为0xCAFFBABE等
2. 验证class文件的元数据，比如类的是否有父类（除了Object的所有类均有父类）等
3. 验证class文件的字节码，比如字节码不会跳转至方法外等

准备：
为类中的static类变量分配空间，并初始化为初始默认值。这里的初始化为变量的默认值，如int为0，boolean为false等。除了一种情况，声明为final的static类变量，编译器在编译时会加入CONSTANT-VALUE属性，在准备阶段即初始化为对应值。

解析：
将类中的字符引用转化为直接引用

#### 初始化
执行生成的cinit方法，来执行类中的static变量赋值语句和static语句块。

如果继承了父类，会先进行父类的初始化，然后才进行本类的初始化

如果实现了接口，不会初始化相应的接口，只会在接口使用到后才进行初始化。

### 对象大小
普通对象占用的空间包含以下部分：
1. 对象头，固定 8 字节
2. 指向类对象的指针，正常 8 字节；如果 JVM 开启类指针压缩，为 4 字节
3. 成员变量占用
   1. 基本数据类型
   2. 普通对象指针，正常 8 字节；如果 JVM 开启对象指针压缩，为 4 字节
4. 对齐空间占用，长度补全对齐 8 的整数倍

数组对象占用空间包含以下部分：
1. 对象头，固定 8 字节
2. 指向数组内容类对象的指针，正常 8 字节；如果 JVM 开启类指针压缩，为 4 字节
3. 数据长度，固定 4 字节
4. 数据内的对象列表
5. 对齐空间占用，长度补全对齐 8 的整数倍

### 乐观锁 vs 悲观锁
#### 悲观锁
悲观锁认为锁的竞争是比较悲观的，锁一旦被某个线程获取会长期持有，其他线程不容易获取到锁，因此线程在获取锁失败后，会考虑释放 CPU 资源进行等待，而不是通过自旋来不停尝试获取锁。
Java 中 Syncronize 与 ReetrantLock 都是悲观锁

#### 乐观锁
乐观认为锁的竞争是比较乐观的，锁被获取后，同步操作较少很快就可以释放，其他线程认为可以在短时间内重新获取锁，因此通过自旋的方式不停尝试获取锁
Java 中 Atomic 原子类都过 CAS 自旋方式进行多线程下的原子操作

